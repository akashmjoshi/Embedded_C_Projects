#include "msp430x26x.h"
#include "lcd.h"
#include "display.h"
#include "math.h"

void SendRequest(void);
void modbusSendUARTPacket ( unsigned char length);
unsigned int modrtuChecksum ( unsigned char *chkbuf, unsigned char len );

uint8_t CommFail[16] = {0};
uint8_t CommFail_1 = 0;
uint8_t CommFail_2 = 0;
uint8_t CommFail_3 = 0;
uint8_t CommFail_4 = 0;

uint8_t active_channel[17];
uint8_t channel_counter = 0;
uint8_t ChannelSent;
uint8_t start_request_counter_flag = 0;
uint8_t j=0,k=0,l=0;
uint16_t channel_check_flag = 0x0001; 
uint16_t QueryCounter[16]; 

uint16_t PvAddress_Sent = 0;

extern uint8_t tx_led_flag;
extern uint8_t timeout_flag ;
extern uint8_t indication_flags_2;
extern uint8_t indication_flags;
extern uint8_t menu;
extern uint8_t RequestTimeoutFlag;
extern unsigned char UART_TX_Buffer[20];
extern uint8_t start_counter;

extern uint16_t Channel_Database[16][5];
extern uint16_t send_counter;
extern uint16_t warmup;
extern uint16_t warm_time1;

extern uint16_t modbus_use_channel_flag  ;

extern ModbusParameters Modbus_Channels[16];

const unsigned char auchCRCHi_exp[] = {
   0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
   0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
   0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01,
   0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41,
   0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81,
   0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0,
   0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01,
   0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40,
   0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
   0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
   0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01,
   0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41,
   0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
   0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0,
   0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01,
   0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81, 0x40, 0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41,
   0x00, 0xc1, 0x81, 0x40, 0x01, 0xc0, 0x80, 0x41, 0x01, 0xc0, 0x80, 0x41, 0x00, 0xc1, 0x81,
   0x40
} ;

const unsigned char auchCRCLo_exp[] = {
   0x00, 0xc0, 0xc1, 0x01, 0xc3, 0x03, 0x02, 0xc2, 0xc6, 0x06, 0x07, 0xc7, 0x05, 0xc5, 0xc4,
   0x04, 0xcc, 0x0c, 0x0d, 0xcd, 0x0f, 0xcf, 0xce, 0x0e, 0x0a, 0xca, 0xcb, 0x0b, 0xc9, 0x09,
   0x08, 0xc8, 0xd8, 0x18, 0x19, 0xd9, 0x1b, 0xdb, 0xda, 0x1a, 0x1e, 0xde, 0xdf, 0x1f, 0xdd,
   0x1d, 0x1c, 0xdc, 0x14, 0xd4, 0xd5, 0x15, 0xd7, 0x17, 0x16, 0xd6, 0xd2, 0x12, 0x13, 0xd3,
   0x11, 0xd1, 0xd0, 0x10, 0xf0, 0x30, 0x31, 0xf1, 0x33, 0xf3, 0xf2, 0x32, 0x36, 0xf6, 0xf7,
   0x37, 0xf5, 0x35, 0x34, 0xf4, 0x3c, 0xfc, 0xfd, 0x3d, 0xff, 0x3f, 0x3e, 0xfe, 0xfa, 0x3a,
   0x3b, 0xfb, 0x39, 0xf9, 0xf8, 0x38, 0x28, 0xe8, 0xe9, 0x29, 0xeb, 0x2b, 0x2a, 0xea, 0xee,
   0x2e, 0x2f, 0xef, 0x2d, 0xed, 0xec, 0x2c, 0xe4, 0x24, 0x25, 0xe5, 0x27, 0xe7, 0xe6, 0x26,
   0x22, 0xe2, 0xe3, 0x23, 0xe1, 0x21, 0x20, 0xe0, 0xa0, 0x60, 0x61, 0xa1, 0x63, 0xa3, 0xa2,
   0x62, 0x66, 0xa6, 0xa7, 0x67, 0xa5, 0x65, 0x64, 0xa4, 0x6c, 0xac, 0xad, 0x6d, 0xaf, 0x6f,
   0x6e, 0xae, 0xaa, 0x6a, 0x6b, 0xab, 0x69, 0xa9, 0xa8, 0x68, 0x78, 0xb8, 0xb9, 0x79, 0xbb,
   0x7b, 0x7a, 0xba, 0xbe, 0x7e, 0x7f, 0xbf, 0x7d, 0xbd, 0xbc, 0x7c, 0xb4, 0x74, 0x75, 0xb5,
   0x77, 0xb7, 0xb6, 0x76, 0x72, 0xb2, 0xb3, 0x73, 0xb1, 0x71, 0x70, 0xb0, 0x50, 0x90, 0x91,
   0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9c, 0x5c,
   0x5d, 0x9d, 0x5f, 0x9f, 0x9e, 0x5e, 0x5a, 0x9a, 0x9b, 0x5b, 0x99, 0x59, 0x58, 0x98, 0x88,
   0x48, 0x49, 0x89, 0x4b, 0x8b, 0x8a, 0x4a, 0x4e, 0x8e, 0x8f, 0x4f, 0x8d, 0x4d, 0x4c, 0x8c,
   0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
   0x40
} ;

void SendRequest(void)
{
	uint8_t i;
	uint16_t tempi; 
		
	if(!(timeout_flag) && (RequestTimeoutFlag) /*&& (warmup == 0)*/  && (indication_flags_2 & START_STOP_COMM) && (menu == NORMAL_MODE)) //&& (indication_flags & SHOW_MODE)
	{
		if(!channel_counter)
		{
			l = 0;
			for(j=0;j<16;j++)
			{
				if(modbus_use_channel_flag & channel_check_flag)
				{
					active_channel[k] = j+1; //(1.442 *  log(modbus_use_channel_flag & channel_check_flag)) + 2;
					channel_counter++;
					k++;
				}
				channel_check_flag = channel_check_flag << 1;
			}
			active_channel[k] = '\0';
			channel_check_flag = 0x0001;
			k = 0;
		}
		
		if(channel_counter)
		{	
			P3DIR |= 0X08;
   			
   			tx_led_flag = 1;
		
			UART_TX_Buffer[0] = Modbus_Channels[active_channel[l] - 1].SlaveID ; //sensor ID 
			
			if(Modbus_Channels[active_channel[l] - 1].ReadRegister == 0)
				UART_TX_Buffer[1] = 0x03;		//function code of holding reg
			else if(Modbus_Channels[active_channel[l] - 1].ReadRegister == 1)
				UART_TX_Buffer[1] = 0x04;		//function code of input reg

			UART_TX_Buffer[2] = (Modbus_Channels[active_channel[l] - 1].PvAddress >> 8);	//address high
			UART_TX_Buffer[3] = (uint8_t)Modbus_Channels[active_channel[l] - 1].PvAddress;	//address low
			UART_TX_Buffer[4] = 0x00;		//length High
			UART_TX_Buffer[5] = 0x01;		//length low
			
			tempi = modrtuChecksum ( UART_TX_Buffer, 6 );
		    UART_TX_Buffer[6] = tempi >> 8;    			//msb of crc	0x84;//
		    UART_TX_Buffer[7] = (unsigned char)tempi;   //lsb of crc	0x0a;//
		    
		    modbusSendUARTPacket(7);
		    
	   		ChannelSent = active_channel[l];
	   		QueryCounter[ChannelSent-1]++;
	   		
	   		PvAddress_Sent = UART_TX_Buffer[2] << 8; 
	        PvAddress_Sent |= (unsigned char)UART_TX_Buffer[3];
	   		
	   		if(QueryCounter[ChannelSent-1] >= 10)
	   		{
	   			CommFail[ChannelSent-1] = 1;
	   			Channel_Database[ChannelSent-1][0] = SLAVE_NOT_RESPONDING; //Error code for Slave Not Responding for PV1
	   			Channel_Database[ChannelSent-1][1] = SLAVE_NOT_RESPONDING; //Error code for Slave Not Responding for PV2
	   			Channel_Database[ChannelSent-1][2] = SLAVE_NOT_RESPONDING; //Error code for Slave Not Responding for PV3
	   			
	   			if(ChannelSent-1 <= 3)
					CommFail_1 = 1;
				else if(ChannelSent-1 >= 4 && ChannelSent-1 <= 7)
					CommFail_2 = 1;
				else if(ChannelSent-1 >= 8 && ChannelSent-1 <= 11)
					CommFail_3 = 1;
				else if(ChannelSent-1 >= 12 && ChannelSent-1 <= 15)
					CommFail_4 = 1;
			}
	   		l++;
	   		channel_counter--;
		}
		   		
		if(channel_counter == 0)
		{
			RequestTimeoutFlag = 0;
	   		start_request_counter_flag = 1;
		}
	}
	
	if(!(indication_flags_2 & START_STOP_COMM))
	{
		for(i=0;i<16;i++)
		{
			Channel_Database[i][0] = COMM_STOP_OR_MAIN_MENU; //Error code for Comm Disabled for PV1
   			Channel_Database[i][1] = COMM_STOP_OR_MAIN_MENU; //Error code for Comm Disabled for PV2
   			Channel_Database[i][2] = COMM_STOP_OR_MAIN_MENU; //Error code for Comm Disabled for PV3
			
		}
		
	}
    start_counter = 1;
}

void modbusSendUARTPacket( unsigned char length)
{
   unsigned char i;
      
   mSetRS485_RTSHigh() ;  // P1.2, SIO pin High
   
   
   // Put data in TX_BUFFER
   for ( i=0; i <= length; i++ )
   {
  	  UCA0TXBUF = UART_TX_Buffer[i];
  	  while(UCA0STAT & UCBUSY);
   }
   
   for ( i=0; i <= 200; i++ );
   
   mSetRS485_RTSLow () ;   // P1.2, SIO pin Low
  
}
    
    


unsigned int modrtuChecksum ( unsigned char *chkbuf, unsigned char len )
{
   unsigned char    uchCRCHi = 0xff ;
   unsigned char    uchCRCLo = 0xff ;
   unsigned int  	uIndex ;
   unsigned int  	temp_code;

   while ( len )
   {
      uIndex = (unsigned int) ( uchCRCHi ^ *chkbuf++ ) ;	
      uchCRCHi = (unsigned char) ( uchCRCLo ^ auchCRCHi_exp[uIndex] ) ;
      uchCRCLo = auchCRCLo_exp[uIndex] ;
      len-- ;
   }
   temp_code = (unsigned int) uchCRCHi;
   temp_code = (unsigned int) (temp_code << 8);
   return(unsigned int) (  temp_code | uchCRCLo ) ;
}
